#(s0-s11): local variables must add to stack
#(t0-t6): global
.data
A:	.words 
B:	.words
C:	.words 

.text
#----------------------------------------------------------------------------------------
#Matrix multiplication function
#a0 = arrazy size
#========================================================================================
matrixMult:
save:	
init:				la	s1,A	#load array A
					la	s2,B	#load array B
					la	s0,C	#load output array 
					mv	s3,x0	# i
					mv	s4,x0	# j
					mv	s5,x0	# k
					
row_loop2:			
#algo goes here
#result[i][j] += m1[i][k] * m2[k][j]
#
#---------------------------------------------------------------------------------------
					addi	sp,sp,-4	#saves ra to stack
					sw		ra,0(sp)

					mv		a2,a0		#moves the size
					
					mv		a0,s3		#i to arg1
					mv		a1,s4		#j to arg2
					mv		a0,s5		#k to arg1
					mv		a1,s5		#k to arg1
				
					
					call	Matrix		#gets the Matrix
					add		t0,a0,(array address) #adds index to appropriate lut
					sw		t1,0(t0)		#stores result at matrix index
					lw		t1,0(t0)		#retrieves value at matrix index
					
					lw		ra,0(sp)	#restores ra
					addi	sp,sp,4
#----------------------------------------------------------------------------------------
					j	row_loop2_admin
col_loop:			j	col_loop_admin					
row_loop1:			j	row_loop1_admin

					
row_loop2_admin:	addi	s5,s5,1
					blt		s5,a0,row_loop2
					mv		s5,x0
					
col_loop_admin:		addi	s4,s4,1
					blt		s4,a0,col_loop
					mv		s4,x0
					
row_loop1_admin:	addi	s3,s3,1
					blt 	s3,a0,row_loop1	
					mv		s3,x0

restore:
return:
#===========================================================================================

#-------------------------------------------------------------------------------------
#Subroutine 1
#retrieves and returns the index
#assumes a0 = i (rows), a1 = j (columns), a2 = size of array, return index in a0
#-------------------------------------------------------------------------------------
Matrix:
save:	addi	sp,sp,-4
		sw		s0,0(sp)
		
init:	mv		s0,x0	
		slli	a0,a0,2			#shift i values to word size
		slli	a3,a3,2			#shift from byte-sized to wordsized array
		
column:	beqz 	a1,row			#branch when number of remaining cols = 0
		add		s0,s0,a3		#shift columns
		addi	a1,a1,-1		#increment loop
		j column
		
row:	srli	a0,a0,2			#shift from wordsized to bytesized 
		add		s0,s0,a0		#add row to lut index
		
admin:	mv		a0,s0			#add the index value to the lut address
		
restore:mv		a1,x0
		mv		a2,x0
		lw		s0,0(sp)
		addi	sp,sp,4
		ret
		
#-------------------------------------------------------------------------------------

#Subroutine 2
#Func Multi <a0,a1>
#Return result in a0 

#Func (a0, a1):
#int x=0, sum=0;
#for (x<=a0):
#	sum = sum + a1
#	x++
#return sum //in a0
#-------------------------------------------------------------------------------------
#Inputs: a0 = index 0, a1 = index 1

Multi:
init:	
	addi	sp,	sp,	-12	#make space (stack 4)
	sw	ra,	8(sp)		#save ra (return address)
	mv	s0,	0			#intialize x (iterator)
	mv	s1,	0			#initialize sum
	sw	s0,	4(sp)		#save x on stack
	sw	s1,	0(sp)		#save sum on stack

loop:	
	bgt	s0,	a0, done	#if x>a0: start return sequence
	add	s1,	s1,	a1		#add sum=sum+a1
	sw	s1,	0(sp)		#store new sum
	addi	s0,	s0,	1	#increment x++
	j	loop			#repeat!

done:
	mv		a1,x0
	mv		a2,x0	
	lw	a0,	0(sp)		#return sum to a0
	lw	ra,	8(sp)		#restore return address	
	addi 	sp,	sp,	12	#restore stack pointer
	ret					#finish
#-----------------------------------------------------------------------------------